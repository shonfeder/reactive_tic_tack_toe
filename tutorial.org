#+TITLE: Reactive Client-Server Apps in OCaml with Eliom
#+PROPERTY: header-args :exports code
#+SETUPFILE: ~/Programming/org/org-html-themes/setup/theme-readtheorg.setup

* Introduction
* Installing OCaml and dependencies
* Initializing the project

  Create a basic project:

  #+BEGIN_SRC sh
  $ eliom-distillery -name rttt -template basic.ppx
  #+END_SRC

** What's included in the basic project template

   src_ocaml{cd} into the directory and see what the template has set up for us:

   #+BEGIN_SRC sh
   $ cd rtt
   $ ls
   Makefile                      README                        rttt.eliom
   Makefile.options              rttt.conf.in                  static
   #+END_SRC

   You should read the SRC_OCAML{README} for a helpful description of these files. But,
   here's a brief account of the essentials:

   - =rttt.eliom= :: The code defining our site goes here.
   - =static= :: Static resources will go here, such as images and CSS files.
   - =Makefile.options= :: Configuration of the project goes here. We'll get to
        this later.

** Building the project and running the test server

   To build the project and run the server, just execute

   #+BEGIN_SRC sh
   $ make test.byte
   #+END_SRC

   Our server is now up and running on the local port. When you point your browser to [[http://localhost:8080/]], you should see the default
   page.

   You can quite sever by pressing =Control+c= in the terminal.

   This is the basic cycle for running functional tests as the project
   develops:

*** Basic work flow

    1. Make changes.
    2. Build the project and run the server with src_ocaml{make test.byte}.
    3. Check out the site by visiting [[http://localhost:8080/]].
    4. Quit the server with =Control+C= and go back to (1).

** The automatically generated files

   After the project builds, a number of files will be automatically generated.
   You don't need to worry about any of these, but a brief description of them
   will help demystify.

   - src_ocaml{_client}, src_ocaml{_server} :: The compiled ocaml files for the client and
        server, respectively.
   - src_ocaml{_deps} :: Dependency information for the complied files.
   - src_ocaml{local} :: Files and logs used by the server.

** Getting Tuareg and Merlin working correctly

   Tooling-wise, the OCaml ecosystem is currently in an awkward state. The
   tooling available is relatively powerful, feature rich, compact, and
   coherent, but the setup can be finicky and requires a lot of manual
   maintenance. These are some tips for coaxing the tooling to behave well on
   Eliom projects.

   Assuming you are using src_ocaml{eliom-distillery} to get started with a template,
   you'll need to add the following to your src_ocaml{.merlin} file to get all the merlin
   goodness:

   #+BEGIN_SRC merlin
   PKG eliom
   PKG eliom.client
   PKG eliom.ppx

   PKG ocsigenserver
   PKG ocsigen-toolkit

   PKG ppx_deriving
   PKG eliom.ppx.server
   PKG eliom.ppx.client

   S _client
   S _server

   B _client
   B _server
   #+END_SRC

   At this point, you have everything in place to begin hacking on the src_ocaml{.eliom}
   file and altering our building out your web app.
* First dive into an Eliom program

  We now take a deep dive in to the anatomy of the src_ocaml{rttt.eliom} file generated
  by the src_ocaml{eliom-distillery} template. We will make some slight changes along
  the way, to clean up some redundancy of the default and make the underlying
  structure more apparent. But the main point of this section is to provide a
  survey the default contents to elucidate the basic elements of an Eliom
  project.

  Readers should skip this section if they're not interested in understanding
  the code in detail at this point. They may revisit it, or consult the Eliom
  manual, when they are ready.

** Anatomy of the generated .eliom file

   An src_ocaml{.eliom} file is just a normal OCaml file, but the build configuration
   knows to include these in the project without explicit declaration of the
   the files in src_ocaml{Makefile.options}.

   There is a single src_ocaml{.eliom} file generated by the template, src_ocaml{rttt.eliom}.
   Let's examine the contents:

   #+BEGIN_SRC ocaml
   [%%shared
       open Eliom_lib
       open Eliom_content
       open Html.D
   ]

   module Rttt_app =
     Eliom_registration.App (
       struct
         let application_name = "rttt"
         let global_data_path = None
       end)

   let main_service =
     Eliom_service.create
       ~path:(Eliom_service.Path [])
       ~meth:(Eliom_service.Get Eliom_parameter.unit)
       ()

   let () =
     Rttt_app.register
       ~service:main_service
       (fun () () ->
         Lwt.return
           (Eliom_tools.F.html
              ~title:"rttt"
              ~css:[["css";"rttt.css"]]
              Html.F.(body [
                h1 [pcdata "Welcome from Eliom's distillery!"];
              ])))
   #+END_SRC

   We proceed with an explanation of each of the four code blocks
   above. They correspond to

   1. Opening modules
   2. Specification of the client-server application
   3. Creation of a service to serve the root URL
   4. Registration of the service with the app

** 1. Opening modules

   #+BEGIN_SRC ocaml
   [%%shared
        open Eliom_lib
        open Eliom_content
        open Html.D
   ]
   #+END_SRC

   The use of the ppx syntax extension src_ocaml{[%%shared ... ]} declares that code
   enclosed in the brackets is /shared/ between the client and the server.
   There are complementary declarations for code that should be available on
   only the /client/ or /server/. The existence of these declarations
   indicates a source of great power and complexity in the Eliom ecosystem:
   one language is used to write code that specifies computations that execute
   on both the client and the server sides. This code goes in the very same
   files and often even in the same function.

   If no declaration is made, the code is server-side only, as is the case for
   the rest of src_ocaml{rttt.eliom} so far. In this code block, however, the contents
   of the three opened modules are made available to all client and server
   code that follows.

** 2. Specification of the App

   #+BEGIN_SRC ocaml
   module Rttt_app =
     Eliom_registration.App (
       struct
         let application_name = "rttt"
         let global_data_path = None
       end)
   #+END_SRC

   Eliom Applications are responsible for coordinating the client-server
   computations. An application is specified with a module satisfying the
   following signature:

   #+BEGIN_SRC ocaml
   module type APP_PARAM = sig
     val application_name : string
     val global_data_path : string list option
   end
   #+END_SRC

   A new application module is created by applying the src_ocaml{Eliom_registration.App}
   functor to a module satisfying this specification. To make the distinction
   between specification and creation explicit, and so that the modules
   articulate the semantics of our program, rather than eliding this with nested
   applications and underscores, we refactor the app creation thus:

   #+BEGIN_SRC ocaml
   module Rttt = struct
     module Info = struct
         let application_name = "rttt"
         let global_data_path = None
     end
     module App = Eliom_registration.App (Info)
   end
   #+END_SRC

** 3. Creating the root service

   #+BEGIN_SRC ocaml
   let main_service =
     Eliom_service.create
     ~path:(Eliom_service.Path [])
     ~meth:(Eliom_service.Get Eliom_parameter.unit)
     ()
   #+END_SRC

   Services are entry points to the website. When we create a service, we
   must provide, at minimum:

   1. A path, specifying the URL where the service is accessed.
   2. The method by which the service is accessed.

   The path is a list of strings: src_ocaml{["foo"; "bar"; "baz"]} describes the
   url src_ocaml{/foo/bar/baz}; src_ocaml{[]} describes the root, src_ocaml{/}.

   The method is specified using value constructors from
   src_ocaml{Eliom_service}.

   In this case, we create a service to provide entry into the root of our
   site and responding to SRC_OCAML{GET} requests carrying no data.

   #+BEGIN_NOTE
   The src_ocaml{Eliom_service.crate} function always takes a unit value as it's
   final argument.
   #+END_NOTE

   The default root service created here is a needlessly verbose due to
   repetition of the src_ocaml{Eliom_service} module qualification.
   Additionally, the ~_~ indicates a semantic distinction and, indeed, we will
   be creating more services soon. All this indicates we should encapsulate this
   in a module:

   #+BEGIN_SRC ocaml
   module Service = struct
     open Eliom_service
     module Param = Eliom_parameter

     let main =
       create
         ~path:(Path [])
         ~meth:(Get Param.unit)
         ()
   end
   #+END_SRC

** 4. Registering the service with a handler

   #+BEGIN_SRC ocaml
   let () =
     Rttt_app.register
       ~service:main_service
       (fun () () ->
         Lwt.return
           (Eliom_tools.F.html
              ~title:"rttt"
              ~css:[["css";"rttt.css"]]
              Html.F.(body [
                h1 [pcdata "Welcome from Eliom's distillery!"];
              ])))
   #+END_SRC

   At this point, we have instantiated the module for managing our client-server
   app, src_ocaml{Rttt.App}, and created a service to serve the root,
   src_ocaml{main_service}. In this block, we put these parts together by
   registering application is to be served by src_ocaml{main_service} and
   handled by an anonymous function.

   First, let's take a step back and see what the register function does in
   general, and then we'll examine the handler in more detail to conclude this
   preliminary survey.

*** The src_ocaml{register} function in general

    src_ocaml{Rttt.App.register} is the service registration for our application
    module. Eliding optional parameters and unnecessary detail, [[https://ocsigen.org/eliom/6.2/api/server/Eliom_registration_sigs.S#2_Serviceregistration][service
    registration functions]] have the following signature:

    #+BEGIN_SRC ocaml
    val register : ~service:(('get, 'post, ...) Eliom_service.t)
                 -> ('get -> 'post -> page Lwt.t)
                 -> unit
    #+END_SRC

    That is, src_ocaml{register} takes one named parameter, src_ocaml{service},
    that specifies the service to register, and one unnamed parameter which is
    the handler for incoming requests to the service. Let's drill into this a
    bit:

    - src_ocaml{Eliom_service.t} :: a service, like our src_ocaml{main_service}
         above, created by src_ocaml{Eliom_service.create}.
    - src_ocaml{...} :: indicates a gnarly knot of type parameters that we needn't
         worry about. It is indicative of unfortunate failure to elegantly
         abstract the complexity of the underlying Eliom mechanisms, but
         generally it is only an eyesore, and needn't be fathomed.
    - src_ocaml{'get} and src_ocaml{'post} :: are type variables which will be
         instantiated with the type of the GET and POST parameters the service
         is able to handle.
    - src_ocaml{('get -> 'post -> page Lwt.t)} :: is the function that handles
         requests to the address served by our service.
    - src_ocaml{page Lwt.t} :: [[https://ocsigen.org/lwt/3.1.0/manual/manual][Lwt]] is an OCaml concurrency library. src_ocaml{'a
         Lwt.t} is a promise that will return something of type src_ocaml{'a}
         when the computation is done. In this case, the handler returns a
         promise to return a src_ocaml{page}, which will be some kind of
         generated HTML.

    The src_ocaml{register} function causes the server to associate the
    specified service with the specified handler, meaning calls to the former
    get served the results of the latter.

*** Our particular handler function

    Consider the handler in isolation:

    #+BEGIN_SRC ocaml
    (fun () () ->
       Lwt.return
         (Eliom_tools.F.html
            ~title:"rttt"
            ~css:[["css";"rttt.css"]]
            Html.F.(body [
              h1 [pcdata "Welcome from Eliom's distillery!"];
            ])))
    #+END_SRC

    In our case, the handler has type src_ocaml{(() -> () -> page Lwt.t)}. This is
    because the src_ocaml{main_service} answers to GET requests without parameters
    (indicated by the src_ocaml{Eliom_paramter.unit} in the creation of the service)
    and there is no service serving requests with POST parameters; thus the
    handler only takes arguments of type src_ocaml{unit}. This type contains no
    information, making it explicit that no information from either GET or
    POST requests is passed along to the handler.

    The function src_ocaml{Lwt.return} takes care of wrapping our page in the type
    src_ocaml{Lwt.t} of Lwt promises.

    src_ocaml{Eliom_tools.F.Html} generates HTML content, taking care of src_ocaml{<head>}
    boilerplate. Optional parameters are used to specify the title and
    resources to be linked (like the external style sheets here). And the
    final argument is an HTML body element.

    The code inside the local module opening src_ocaml{Html.F.(...)} specifies the body
    element. src_ocaml{Html.F} is a submodule of src_ocaml{Eliom_content}, which was opened at
    the beginning of the file. Eliom apps are encouraged to use functions from
    the src_ocaml{Eliom_content.Html.F}, src_ocaml{Eliom_content.Html.D}, src_ocaml{Eliom_content.Html.D}
    modules to generate type-safe, statically verified HTML (more on their
    differences soon). There are [[https://ocsigen.org/eliom/6.2/manual/clientserver-html#server_generating_html][other options]], but we will not discuss them.

    Finally, we generate a src_ocaml{body} element containing an src_ocaml{h1} heading with the
    text "Welcome from Eliom's distillery!".

**** Refactoring the handler

     We said above that the src_ocaml{Rttt.App.register} associates a servicer
     with a handler. The code generated by the template obscures the simplicity
     of this action a bit because of the complexity of the anonmyous function
     provided as the handler. Moreover, the presence of the underscore and the
     fact that we're going to have more than one handler indicates we should be
     using a module. So we make one final tweak to the template:

     #+BEGIN_SRC ocaml
     module Handler = struct
       let page = Eliom_tools.F.html

       let main _get _post =
         let body = let open Html.F in
           body [h1 [pcdata "Welcome from Eliom's distillery!"]]
         in
         Lwt.return @@ page
           ~title:"rttt"
           ~css:[["css";"rttt.css"]]
           body
     end
     #+END_SRC

     src_ocaml{Rtt.App.regiser} associates src_ocaml{main_service} with src_ocaml{main_handler}. The
     handler has parameters for GET and POST requests, but they are not used
     here, so they marked as discarded with preceding underscores. Finally, we
     build the body in a src_ocaml{let} expression, before returning a promise to
     generate our main page.

** The revised state of the default file

   =rttt.eliom= now looks like this:

   #+BEGIN_SRC ocaml
[%%shared
    open Eliom_lib
    open Eliom_content
    open Html.D
]

module Rttt = struct
  module Info = struct
    let application_name = "rttt"
    let global_data_path = None
  end
  module App = Eliom_registration.App (Info)
end

module Service = struct
  open Eliom_service
  module Param = Eliom_parameter

  let main =
    create
      ~path:(Path [])
      ~meth:(Get Param.unit)
      ()
end

module Handler = struct
  let page = Eliom_tools.F.html

  let main _get _post =
    let body = let open Html.F in
      body [h1 [pcdata "Reactive Tic-Tac-Toe"]]
    in
    Lwt.return @@ page
      ~title:"rttt"
      ~css:[["css";"rttt.css"]]
      body
end

let () =
  Rttt.App.register
    ~service:Service.main
    Handler.main
   #+END_SRC
* Servicing GET requests: Creating a game room

  We want this app to support multiple ongoing games. Each game will be
  identified with an integer. GET requests to =/games= will supply the integer
  to the =id= parameter, and this will retrieve the matching game, if it exists,
  or fall back to the /game room/. The /game room/ will be a list of ongoing
  games, served at the url =/games= when no parameters are supplied.

** A game page is a service answering simple GET requests

   Let's start by creating and registering a service to serve the GET requests and
   a handler to respond to incoming queries. We will add the following:

   - a ~game~ service to the src_ocaml{Service} module ::
   #+BEGIN_SRC ocaml
   let game =
     create
       ~path:(Path ["game"])
       ~meth:(Get (Param.int "id"))
       ()
   #+END_SRC

   This creates a service for the url =/games= which responds get params ~id=n~,
   where n is some integer. An example of a GET request that would land on this
   service is =/games?id=3=.

   - a ~game~ handler to the src_ocaml{Handler} module ::
   #+BEGIN_SRC ocaml
   let game id _post =
     let game_number = Printf.sprintf "Game #%i" id in
     let body = let open Html.F in
       body [h1 [pcdata game_number]]
     in
     Lwt.return @@ basic_page
       ~title:("Reactive Tic-Tac-Toe " ^ game_number)
       body
   #+END_SRC

   This time, we are actually receiving an informative GET parameter, into the
   src_ocaml{id} variable. This parameter, which we know will be an integer from
   the specification of the game service, is used to construct a string
   indicating the game number.

   - a call to register the handler service with our app ::
   This is virtually identical to the registration of =main=
   #+BEGIN_SRC ocaml
   let () =
     Rttt.App.register
       ~service:Service.game
       Handler.game
   #+END_SRC

   If you build the project and point your browser to
   [[http://localhost:8080/games?id=3923]], you should be greeted with the
   heading "Game #3923".
* Defining the game of hang man
** Adding package dependencies

   Add ~containers~ and ~ppx_deriving.show~ to the list of required packages:

   #+BEGIN_SRC makefile
   # OCamlfind packages for the server
   SERVER_PACKAGES := lwt.ppx js_of_ocaml.deriving.ppx containers ppx_deriving.show
   # OCamlfind packages for the client
   CLIENT_PACKAGES := lwt.ppx js_of_ocaml.ppx js_of_ocaml.deriving.ppx containers ppx_deriving.show
   #+END_SRC
* Adding reactivity
** Adding package dependencies

   Add ~react~ to the list of required packages:

   #+BEGIN_SRC makefile
   # OCamlfind packages for the server
   SERVER_PACKAGES := lwt.ppx js_of_ocaml.deriving.ppx react
   # OCamlfind packages for the client
   CLIENT_PACKAGES := lwt.ppx js_of_ocaml.ppx js_of_ocaml.deriving.ppx react
   #+END_SRC
