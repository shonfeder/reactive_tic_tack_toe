* Tutorial
** Installing OCaml and dependencies
** Initializing the project

   Create a basic project:

   #+BEGIN_SRC sh
   $ eliom-distillery -name rttt -template basic.ppx
   #+END_SRC

*** What's included in the basic project template

    ~cd~ into the directory and see what the template has set up for us:

    #+BEGIN_SRC sh
    $ cd rtt
    $ ls
    Makefile                      README                        rttt.eliom
    Makefile.options              rttt.conf.in static
    #+END_SRC

    You should read the ~README~ for a helpful description of these files. But,
    here's a brief account of the essentials:

    - ~rttt.eliom~ :: The code defining our site goes here.
    - ~static~ :: Static resources will go here, such as images and CSS files.
    - ~Makefile.options~ :: Configuration of the project goes here. We'll get to
         this later.

*** Building the project and running the test server

    To build the project and run the server, just execute

    #+BEGIN_SRC sh
    $ make test.byte
    #+END_SRC

    Our server is now up and running on the local port. When you point your browser to [[http://localhost:8080/]], you should see the default
    page.

    You can quite sever by pressing =Control+c= in the terminal.

    This is the basic cycle for running functional tests as the project
    develops:

**** Basic work flow

     1. Make changes.
     2. Build the project and run the server with ~make test.byte~.
     3. Check out the site by visiting [[http://localhost:8080/]].
     4. Quit the server with =Control+C= and go back to (1).

*** The automatically generated files

    After the project builds, a number of files will be automatically generated.
    You don't need to worry about any of these, but a brief description of them
    will help demystify.

    - ~_client~, ~_server~ :: The compiled ocaml files for the client and
         server, respectively.
    - ~_deps~ :: Dependency information for the complied files.
    - ~local~ :: Files and logs used by the server.

*** Getting Tuareg and Merlin working correctly

    Tooling-wise, the OCaml ecosystem is currently in an awkward state. The
    tooling available is relatively powerful, feature rich, compact, and
    coherent, but the setup can be finicky and requires a lot of manual
    maintenance. These are some tips for coaxing the tooling to behave well on
    Eliom projects.

    Assuming you are using ~eliom-distillery~ to get started with a template,
    you'll need to add the following to your ~.merlin~ file to get all the merlin
    goodness:

    #+BEGIN_SRC merlin
    PKG eliom
    PKG eliom.client
    PKG eliom.ppx

    PKG ocsigenserver
    PKG ocsigen-toolkit

    PKG ppx_deriving
    PKG eliom.ppx.server
    PKG eliom.ppx.client

    S _client
    S _server

    B _client
    B _server
    #+END_SRC

    At this point, you have everything in place to begin hacking on the ~.eliom~
    file and altering our building out your web app.

** First dive into an Eliom program

   We now take a deep dive in to the anatomy of the ~rttt.eliom~ file generated
   by the ~eliom-distillery~ template. We will make some slight changes along
   the way, to clean up some redundancy of the default and make the underlying
   structure more apparent. But the main point of this section is to provide a
   survey the default contents to elucidate the basic elements of an Eliom
   project.

   Readers should skip this section if they're not interested in understanding
   the code in detail at this point. They may revisit it, or consult the Eliom
   manual, when they are ready.

*** Anatomy of the generated .eliom file

    An ~.eliom~ file is just a normal OCaml file, but the build configuration
    knows to include these in the project without explicit declaration of the
    the files in ~Makefile.options~.

    There is a single ~.eliom~ file generated by the template, ~rttt.eliom~.
    Let's examine the contents:

    #+BEGIN_SRC ocaml
    [%%shared
        open Eliom_lib
        open Eliom_content
        open Html.D
    ]

    module Rttt_app =
      Eliom_registration.App (
        struct
          let application_name = "rttt"
          let global_data_path = None
        end)

    let main_service =
      Eliom_service.create
        ~path:(Eliom_service.Path [])
        ~meth:(Eliom_service.Get Eliom_parameter.unit)
        ()

    let () =
      Rttt_app.register
        ~service:main_service
        (fun () () ->
          Lwt.return
            (Eliom_tools.F.html
               ~title:"rttt"
               ~css:[["css";"rttt.css"]]
               Html.F.(body [
                 h1 [pcdata "Welcome from Eliom's distillery!"];
               ])))
    #+END_SRC

    We proceed with an explanation of each of the four code blocks
    above. They correspond to

    1. Opening modules
    2. Specification of the client-server application
    3. Creation of a service to serve the root URL
    4. Registration of the service with the app

**** 1. Opening modules

     #+BEGIN_SRC ocaml
     [%%shared
          open Eliom_lib
          open Eliom_content
          open Html.D
     ]
     #+END_SRC

     The use of the ppx syntax extension ~[%%shared ... ]~ declares that code
     enclosed in the brackets is /shared/ between the client and the server.
     There are complementary declarations for code that should be available on
     only the /client/ or /server/. The existence of these declarations
     indicates a source of great power and complexity in the Eliom ecosystem:
     one language is used to write code that specifies computations that execute
     on both the client and the server sides. This code goes in the very same
     files and often even in the same function.

     If no declaration is made, the code is server-side only, as is the case for
     the rest of ~rttt.eliom~ so far. In this code block, however, the contents
     of the three opened modules are made available to all client and server
     code that follows.

**** 2. Specification of the App

     #+BEGIN_SRC ocaml
     module Rttt_app =
       Eliom_registration.App (
         struct
           let application_name = "rttt"
           let global_data_path = None
         end)
     #+END_SRC

     Eliom Applications are responsible for coordinating the client-server
     computations. An application is specified with a module satisfying the
     following signature:

     #+BEGIN_SRC ocaml
     module type APP_PARAM = sig
       val application_name : string
       val global_data_path : string list option
     end
     #+END_SRC

     It is created by apply the ~Eliom_registration.App~ functor to such a
     module, creating a new application module. I like to make this distinction
     explicit, and I like to structure my modules to articulate the semantics of
     my program, rather than elide with nested applications and underscores; so
     I alter the app registration like so

     #+BEGIN_SRC ocaml
     module Rttt = struct
       module Info = struct
           let application_name = "rttt"
           let global_data_path = None
       end
       module App = Eliom_registration.App (Info)
     end
     #+END_SRC

**** 3. Creating the root service

     #+BEGIN_SRC ocaml
     let main_service =
       Eliom_service.create
       ~path:(Eliom_service.Path [])
       ~meth:(Eliom_service.Get Eliom_parameter.unit)
       ()
     #+END_SRC

     Services are entry points to the website. When we create a service, we
     must provide, at minimum:

     1. A path, specifying the URL where the service is accessed.
     2. The method by which the service is accessed.

     The path is a list of strings: ~["foo"; "bar"; "baz"]~ describes the url
     ~/foo/bar/baz~; ~[]~ describes the root, ~/~.

     The method is specified using value constructors from ~Eliom_service~.

     In this case, we create a service to provide entry into the root of our
     site and responding to ~GET~ requests carrying no data.

     #+BEGIN_NOTE
     The ~Eliom_service.crate~ function always takes a unit value as it's final
     argument.
     #+END_NOTE

     The default root service created here is a needlessly verbose due to
     repetition of the ~Eliom_service~ module qualification, so I'll clean it up
     with a local open:

     #+BEGIN_SRC ocaml
     let main_service =
       let open Eliom_service in
       create ~path:(Path []) ~meth:(Get Eliom_parameter.unit) ()
     #+END_SRC

**** 4. Registering the service

     #+BEGIN_SRC ocaml
     let () =
       Rttt_app.register
         ~service:main_service
         (fun () () ->
           Lwt.return
             (Eliom_tools.F.html
                ~title:"rttt"
                ~css:[["css";"rttt.css"]]
                Html.F.(body [
                  h1 [pcdata "Welcome from Eliom's distillery!"];
                ])))
     #+END_SRC

     At this point, we have instantiated the module for managing our
     client-server app, ~Rttt.App~, and created a service to serve the root,
     ~main_service~. In this block, we put these parts together by registering
     application is to be served by ~main_service~ and handled by an anonymous
     function.

     First, let's take a step back and see what the register function does in
     general, and then we'll examine the handler in more detail to conclude this
     preliminary survey.

***** The ~register~ function in general

      ~Rttt.App.register~ is the service registration for our application
      module. Eliding optional parameters and unnecessary detail, [[https://ocsigen.org/eliom/6.2/api/server/Eliom_registration_sigs.S#2_Serviceregistration][service
      registration functions]] have the following signature:

      #+BEGIN_SRC ocaml
      val register : ~service:(('get, 'post, ...) Eliom_service.t)
                   -> ('get -> 'post -> page Lwt.t)
                   -> unit
      #+END_SRC

      That is, ~register~ takes one named parameter, ~service~, that specifies
      the service to register, and one unnamed parameter which is the handler
      for incoming requests to the service. Let's drill into this a bit:

      - ~Eliom_service.t~ :: a service, like our ~main_service~ above, created
           by ~Eliom_service.create~.
      - ~...~ :: indicates a gnarly knot of type parameters that we needn't
           worry about. It is indicative of unfortunate failure to elegantly
           abstract the complexity of the underlying Eliom mechanisms, but
           generally it is only an eyesore, and needn't be fathomed.
      - ~\'get~ and ~\`post~ :: are type variables which will be instantiated
           with the type of the GET and POST parameters the service is able to
           handle.
      - ~('get -> 'post -> page Lwt.t)~ :: is the function that handles requests
           to the address served by our service.
      - ~page Lwt.t~ :: [[https://ocsigen.org/lwt/3.1.0/manual/manual][Lwt]] is an OCaml concurrency library. ~'a Lwt.t~ is a
           promise that will return something of type ~\'a~ when the computation
           is done. In this case, the handler returns a promise to return a
           ~page~, which will be some kind of generated HTML.

      The ~register~ function causes the server to associate the specified
      service with the specified handler, meaning calls to the former get served
      the results of the latter.

***** Our particular handler function

      Consider the handler in isolation:

      #+BEGIN_SRC ocaml
      (fun () () ->
         Lwt.return
           (Eliom_tools.F.html
              ~title:"rttt"
              ~css:[["css";"rttt.css"]]
              Html.F.(body [
                h1 [pcdata "Welcome from Eliom's distillery!"];
              ])))
      #+END_SRC

      In our case, the handler has type ~(() -> () -> page Lwt.t)~. This is
      because the ~main_service~ answers to GET requests without parameters
      (indicated by the ~Eliom_paramter.unit~ in the creation of the service)
      and there is no service serving requests with POST parameters; thus the
      handler only takes arguments of type ~unit~. This type contains no
      information, making it explicit that no information from either GET or
      POST requests is passed along to the handler.

      The function ~Lwt.return~ takes care of wrapping our page in the type
      ~Lwt.t~ of Lwt promises.

      ~Eliom_tools.F.Html~ generates HTML content, taking care of ~<head>~
      boilerplate. Optional parameters are used to specify the title and
      resources to be linked (like the external style sheets here). And the
      final argument is an HTML body element.

      The code inside the local module opening ~Html.F.(...)~ specifies the body
      element. ~Html.F~ is a submodule of ~Eliom_content~, which was opened at
      the beginning of the file. Eliom apps are encouraged to use functions from
      the ~Eliom_content.Html.F~, ~Eliom_content.Html.D~, ~Eliom_content.Html.D~
      modules to generate type-safe, statically verified HTML (more on their
      differences soon). There are [[https://ocsigen.org/eliom/6.2/manual/clientserver-html#server_generating_html][other options]], but we will not discuss them.

      Finally, we generate a ~body~ element containing an ~h1~ heading with the
      text "Welcome from Eliom's distillery!".

****** Refactoring the handler

       We said above that the ~Rttt.App.register~ associates a servicer with a
       handler. The code generated by the template obscures the simplicity of
       this action a bit because of the complexity of the anonmyous function
       provided as the handler. Let's make one final tweak to the template to
       make this separation of concerns evident:

       #+BEGIN_SRC ocaml
       let main_handler _get _post =
         let body = let open Html.F in
           body [h1 [pcdata "Reactive Tic-Tack-Toe in Eliom"]]
         in
         Lwt.return
           (Eliom_tools.F.html
              ~title:"rttt"
              ~css:[["css";"rttt.css"]]
              body)

       let () =
         Rttt.App.register
           ~service:main_service
           main_handler
       #+END_SRC

       ~Rtt.App.regiser~ associates ~main_service~ with ~main_handler~. The
       handler has parameters for GET and POST requests, but they are not used
       here, so they marked as discarded with preceding underscores. Finally, we
       build the body in a ~let~ expression, before returning a promise to
       generate our main page.
