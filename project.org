* Notes
* Tasks
* Tutorial
** Installing OCaml and dependencies
** Initializing the project

   Create a basic project:

   #+BEGIN_SRC sh
   $ eliom-distillery -name rttt -template basic.ppx
   #+END_SRC

*** What the basic project template includes

    ~cd~ into the directory and see what the template has set up for us:

    #+BEGIN_SRC sh
    $ cd rtt
    $ ls
    Makefile                      README                        rttt.eliom
    Makefile.options              rttt.conf.in static
    #+END_SRC

    You should read the ~README~ for a helpful description of these files. But,
    here's a brief account of the essentials:

    - ~rttt.eliom~ :: The code defining our site goes here.
    - ~static~ :: Static resources will go here, such as images and CSS files.
    - ~Makefile.options~ :: Configuration of the project goes here. We'll get to
         this later.

*** Building the project and running the test server

    To build the project and run the server, just execute

    #+BEGIN_SRC sh
    $ make test.byte
    #+END_SRC

    When you point your browser to http://localhost:8080/, you should see the default
    page.

    You can quite sever by pressing =Control+c= in the terminal.

    This is the basic cycle for running functional tests as the project
    develops:

**** Basic work flow

     1. Make changes.
     2. Build the project and run the server with ~make test.byte~.
     3. Check out the site by visiting http://localhost:8080/.
     4. Quit the server with =Control+C= and go back to (1).
*** The automatically generated files

    After the project builds, a number of files will be automatically generated.
    You don't need to worry about any of these, but a brief description of them
    will help demystify.

    - ~_client~, ~_server~ :: The compiled ocaml files for the client and
         server, respectively.
    - ~_deps~ :: Dependency information for the complied files.
    - ~local~ :: Files and logs used by the server.
         
*** Getting Tuareg and Merlin working correctly

    Tooling-wise, the OCaml ecosystem is currently in an awkward state. The
    tooling available is relatively powerful, feature rich, compact, and
    coherent, but the setup can be finicky and requires a lot of manual
    maintenance. These are some tips for coaxing the tooling to behave well on
    Eliom projects.

    Assuming you are using ~eliom-distillery~ to get started with a template,
    you'll need to add the following to your ~.merlin~ file to get all the merlin
    goodness:

    #+BEGIN_SRC merlin
    PKG eliom
    PKG eliom.client
    PKG eliom.ppx

    PKG ocsigenserver
    PKG ocsigen-toolkit

    PKG ppx_deriving
    PKG eliom.ppx.server
    PKG eliom.ppx.client

    S _client
    S _server

    B _client
    B _server
    #+END_SRC

*** Anatomy of the generated eliom file

    An ~.eliom~ file is just a normal OCaml file, but the Eliom compiler knows
    to include these in the project build without having to explicitly declare
    the file in the list of dependencies in the ~Makefile.options~. Take a look
    at the default contents of ~rttt.eliom~.

    #+BEGIN_SRC ocaml
    [%%shared
        open Eliom_lib
        open Eliom_content
        open Html.D
    ]

    module Rttt_app =
      Eliom_registration.App (
        struct
          let application_name = "rttt"
          let global_data_path = None
        end)

    let main_service =
      Eliom_service.create
        ~path:(Eliom_service.Path [])
        ~meth:(Eliom_service.Get Eliom_parameter.unit)
        ()

    let () =
      Rttt_app.register
        ~service:main_service
        (fun () () ->
          Lwt.return
            (Eliom_tools.F.html
               ~title:"rttt"
               ~css:[["css";"rttt.css"]]
               Html.F.(body [
                 h1 [pcdata "Welcome from Eliom's distillery!"];
               ])))
    #+END_SRC

    Before we begin building out our project on top of this scaffold, let's
    survey the current contents to illuminate the basic elements of an Eliom
    project. We proceed with an explanation of each of the four code blocks
    above. They correspond to

    1. Module imports
    2. Specification of the client-server application
    3. Creation of a service to serve the app from the root URL
    4. Registering the app to be served with generated HTML at that service

**** 1. Module Imports

     #+BEGIN_SRC ocaml
     [%%shared
          open Eliom_lib
          open Eliom_content
          open Html.D
     ]
     #+END_SRC

**** 2. Specification of the App

     #+BEGIN_SRC ocaml
     module Rttt_app =
       Eliom_registration.App (
         struct
           let application_name = "rttt"
           let global_data_path = None
         end)
     #+END_SRC

**** 3. Creating the root service

     #+BEGIN_SRC ocaml
     let main_service =
       Eliom_service.create
       ~path:(Eliom_service.Path [])
       ~meth:(Eliom_service.Get Eliom_parameter.unit)
       ()
    #+END_SRC

**** 4. Registering the service

     #+BEGIN_SRC ocaml
     let () =
       Rttt_app.register
         ~service:main_service
         (fun () () ->
           Lwt.return
             (Eliom_tools.F.html
                ~title:"rttt"
                ~css:[["css";"rttt.css"]]
                Html.F.(body [
                  h1 [pcdata "Welcome from Eliom's distillery!"];
                ])))
     #+END_SRC

** Creating Services

   The basic structure of Eliom sites is based around services.
